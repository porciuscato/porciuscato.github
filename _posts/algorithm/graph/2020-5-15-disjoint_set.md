---
title: 그래프 상포 배타집합
published: true
updated: 2020-5-15
tags: [python, algorithm, graph, disjoint-set]
categories: [development]
---

상호배타집합에 대해 알아보자



## 상호 배타 집합

#### 서로소 또는 상호 배타 집합들

- 서로 중복 포함된 원소가 없는 집합들로 교집합이 없음
- 집합에 속한 하나의 특정 원소를 통해 각 집합들을 구분
  - 특정 원소 - 대표자(Representative)
- 상호배타 집합을 표현하는 방법
  - 연결리스트
  - 트리

#### 상호 배타 집합의 연산

- make-set(x) 
  - 원소 x 만으로 구성된 집합을 생성하는 연산
- find-set(x)
  - 임의의 원소 x가 속한 집합을 알아내기 위해 사용하며 집합의 대표자를 알기 위한 연산
- union(x, y)
  - x 원소가 속한 집합과 y 원소가 속한 집합을 하나의 집합으로 합치는 연산



#### 연결리스트 표현

- 같은 집합의 원소들은 하나의 연결 리스트로 관리
- 연결리스트의 첫 번째 원소를 집합의 대표 원소로 선택
- 각 원소는 집합의 대표원소를 가리키는 링크를 가짐



##### 연결리스트 연산

- a ~ f 까지 make_set()을 해 집합으로 바꾼다.

- e를 a와 합친다.

  - Union(find_set(a), find_set(e))

- f를 b와 합친다.

  - Union(find_set(b), find_set(f))

- e가 속한 집합과 f가 속한 집합을 합친다.

  - find_set(e)    =>    return a

  - find_set(f)     =>    return b

  - Union(a, b)

    \+ 두 집합을 합칠 때는 크기가 작은 집합을 큰 집합의 뒤에 연결

    - a 집합의 꼬리 노드가 b 집합의 머리를 가리키게 만든다.
    - b 집합의 모든 노드가 부모 노드로 a 노드를 가리키도록 만든다.



#### 트리 표현

> 연결리스트보다 효율적이다.

- 하나의 집합(a disjoint set)을 하나의 트리로 표현
- 자식 노드가 부모 노드를 가리키며 루트 노드는 자기 자신을 가리킨다. 루트 노드가 대표자가 됨



##### 트리 연산

- a ~ f까지 make_set() 집합으로 만든다.
  - 각각 자신을 루트로 하는 트리가 생성된다.
- union(c, d)  |  union(e, f)
  - 두 집합의 대표자 중의 하나가 다른 집합의 대표자를 부모로 가리키면 된다.
  - 이렇게 하면 연결리스트에 비해 간단하다
- find_set()을 수행하면 부모 노드가 자기 자신인 노드를 찾을 때까지 반복하면 된다.



##### 트리로 표현하기 위해 리스트를 사용한다.

| 원소    | 0    | 1    | 2    | 3    | 4    | 5    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 부모(p) | 0    | 1    | 2    | 2    | 2    | 4    |

> 각 원소의 부모에 대한 정보 저장 형태
>
> 그래프 알고리즘에서는 정점들을 원소로 하는 상호 배타 집합들을 이용



##### 상호 배타 집합의 연산들에 대한 알고리즘

- Make_set(x)

  - 유일한 원소 x를 포함하는 새로운 집합을 생성하는 연산

    ```python
    # p는 일차원 배열로서 각 원소들의 부모 노드를 가리킨다.
    
    def Make_set(x):
        p[x] = x
    ```

- Find_set(x)

  - x를 포함하는 집합을 찾는 연산

    ```python
    def Find_set(x):
        if x == p[x]: return x
        else: return Find_set(p[x])
    ```

- Union(x, y)

  - x와 y를 포함하는 두 집합을 통합하는 연산

    ```python
    def Union(x, y):
        p[Find_set(y)] = Find_set(x)
    ```

    

#### 상호 배타 집합을 트리로 표현 시 대표적 문제점

- 집합 union 과정에서 편향된 트리 구조가 생성될 수 있다.

  - 간선의 수만큼 재귀 호출이 필요하다.

  => **모든 간선들이 부모를 가리키도록 해야한다.**



##### 연산의 효율을 높이는 방법

1. Rank를 이용한 Union

   - 각 노드는 자신을 루트로 하는 Subtree의 높이를 랭크(rank)라는 이름으로 저장
   - 두 집합을 합칠 때 Rank가 낮은 집합을 Rank가 높은 집합에 붙임

   \+ 랭크를 이용하여 Union을 할 때

   	- 두 랭크의 높이가 다르면 랭크의 값을 변경할 필요가 없다.
   	- 하지만 두 랭크의 높이가 같다면 루트 노드의 Rank를 1 높여야 한다.



2. Path compression(경로 압축)

   - Find_set을 행하는 과정에서 만나는 모든 노드들이 직접 Root를 가리키도록 부모 정보를 변경

   \+ Find_set을 하면 해당하는 트리의 루트 정보가 나오는데, 돌아오면서 노드의 모든 부모를 루트로 바꿔준다. (재귀로 구현)



### 상호 배타 집합 코드

> 효율성을 고려해서 작성된 알고리즘이다.

- Make_set() 연산

  ```python
  # p[x]: 노드 x의 부모 저장
  # rank[x]: 루트 노드가 x인 트리의 랭크 값 저장
  
  def Make_set(x):
      p[x] = x # 부모를 자기 자신으로 설정
      rank[x] = 0 # 높이를 0으로 설정
  ```

- Find_set() 연산

  ```python
  def Find_set(x):
      if x != p[x]:
          p[x] = Find_set(p[x])   # path compression
      return p[x]
  ```
  - 특정 노드에서 루트까지의 경로가 경로에 존재하는 노드가 루트를 부모로 가리키도록 갱신

- Union() 연산

  ```python
  def Union(x, y):
  	Link(Find_set(x), Find_set(y))
  ```

  ```python
  def Link(x, y):
      if rank[x] > rank[y]:
          p[y] = x
      else:
          p[x] = y
      if rank[x] == rank[y]:
          rank[y] += 1
  ```

  

##### 상호 배타 집합

- 구현이 간단하고 동작 속도가 빠르기 때문에 그래프 영역에서 많이 사용되고 다른 알고리즘의 일부로 활용
  - 그래프의 연결성 확인하기
  - Kruskal Minimum Spanning Tree(MST) 알고리즘

- 각 집합에 속한 원소의 수 관리

  > 트리의 원소 개수를 저장하는 size 변수를 추가하여 두 집합이 합쳐질 떄마다 이 값을 갱신하여 각 트리의 원소의 개수를 알 수 있다.

  - 가장 큰 집합 추적하기

  - 집합의 노드 개수가 몇 개 이상이 되는 시점 찾기