---
title: Tree 자료구조에 대해 알아보자
published: false
updated: 2020-5-2
tags: [python, tree, algorithm]
categories: [development]
---

Tree에 대해 알아보자



## 개념

- Tree
  - 비선형 구조로 원소들 간에 1:n 관계를 가지는 자료구조
    - 원소들 간에 계층관계를 가지는 계층형 자료구조
    - 상위 원소에서 하위 원소로 내려가면서 확장되는 Tree 모양의 구조
- 특성
  - 한 개 이상의 노드로 이루어진 유한 집합
    - root: 노드 중 최상위 노드
    - 나머지 노드들: n개의 분리집합. T1, T2....,TN으로 분리될 수 있음
  - 이들 T1,....,TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 서브트리(SubTree)라고 함

- 구성요소 : 노드, 간선
  - 노드
    - 트리의 원소
  - 간선
    - 노드를 연결하는 선
    - 부모 노드와 자식 노드를 연결
  - **노드의 종류**
    - 루트 노드
      - 트리의 시작 노드
    - 형제 노드
      - 같은 부모 노드의 자식 노드
    - 조상 노드
      - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
    - 서브 트리
      - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
    - 자손 노드
      - 서브트리에 있는 하위 레벨의 노드들
  - **차수**
    - 차수의 의미: 노드에 연결된 자식의 수
    - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
    - 단말 노드(리프 노드): 차수가 0인 노드 - 자식 노드가 없는 노드
  - **높이**
    - 노드의 높이
      - 루트까지 높이
    - 트리의 높이 or 트리의 레벨
      - 트리에 있는 노드의 높이 중에서 가장 큰 값



## 바이너리 트리 구현

- 노드

  ```python
  class Node:
      def __init__(self, data):
          self.data = data
          self.left = None
          self.right = None
          self.parent = None # 노드 삭제 구현의 용이를 위해 
  ```

트리를 구성하는 노드다. 주로 data, left, right만 있지만 노드 삭제 구현의 용이를 위해 parent를 넣었다.

- 트리

  ```python
  class BinaryTree:
      # 트리의 인스턴스를 생성할 때 노드를 인자로 전달한다.
      def __init__(self, root_node):
          self.root = root_node
      
      def get_root(self):
          return self.root
  ```

  - 삽입

  ```python
      def insert(self, value):
          now_node = self.root  # 현재 노드
          prev_node = now_node  # 이전 노드를 미리 저장한다. 
  
          # while 문으로 들어갈 위치를 찾는다.
          while now_node:  # 리프노드의 경우 자식이 None이 나온다.
              prev_node = now_node
              if value < now_node.data:
                  now_node = now_node.left
                  left = True # 왼쪽, 혹은 오른쪽 자식임을 미리 표시한다.
              else:
                  now_node = now_node.right
                  left = False
           
          # 들어갈 위치를 찾았으면 노드를 생성하여 트리에 붙인다.
          # 붙일 노드는 prev_node이고 위치는 left(True or False)다.
          new_node = Node(value)  # 노드를 새로 생성한다.
          new_node.parent = prev_node  # 새로 생성한 노드의 부모를 리프노드로
          if left: # 왼쪽 자식일 경우 왼쪽에 붙인다.
              prev_node.left = new_node
          else: # 오른쪽 자식일 경우 오른쪽에 붙인다.
              prev_node.right = new_node
  ```

  - 삽입2 : left와 prev_node를 사용하지 않고

    ```python
        def insert2(self, value):
            now_node = self.root
            while now_node:
                if value < now_node.data:
                    # 왼쪽이 비어있으면 왼쪽에 새 노드를 넣고 종료
                    if now_node.left is None:
                        new_node = Node(value)
                        now_node.left = new_node
                        new_node.parent = now_node
                        break
                    else:
                        now_node = now_node.left
                else:
                    # 오른쪽이 비어있으면 오른쪽에 새 노드를 넣고 종료
                    if now_node.right is None:
                        new_node = Node(value)
                        now_node.right = new_node
                        new_node.parent = now_node
                        break
                    else:
                        now_node = now_node.right
    ```

  - 최대, 최소값 노드 찾기

  ```python
  	# 특정 노드를 넣으면 그 노드의 서브트리에서 최대, 최소값을 찾는다.
  	def find_mx(self, node):
          now_node = node
          # 오른쪽으로 계속 간다.
          while now_node:
  			if now_node.right is None:
  				return now_node
              else:
                  now_node = now_node.right
      
      def find_mn(self, node):
          now_node = node
          # 왼쪽으로 계속간다.
          while now_node:
              if now_node.left is None:
                  return now_node
              else:
  				now_node = now_node.left            
  ```

  

```python


    def delete(self, value):
        now_node = self.root
        while now_node:
            if value == now_node.data:
                if now_node == self.root:
                    if now_node.left:
                        mx_node = self.find_mx(now_node.left)
                        mx_node.left = now_node.left
                        mx_node.right = now_node.right
                        if mx_node.parent.left == mx_node:
                            mx_node.parent.left = None
                        else:
                            mx_node.parent.right = None
                        self.root = mx_node
                    elif now_node.right:
                        mn_node = self.find_mn(now_node.right)
                        mn_node.left = now_node.left
                        mn_node.right = now_node.right
                        if mn_node.parent.left == mn_node:
                            mn_node.parent.left = None
                        else:
                            mn_node.parent.right = None
                        self.root = mn_node
                    else:
                        self.root = None
                    return value
                if now_node.left:
                    mx_node = self.find_mx(now_node.left)
                    mx_node.left = now_node.left
                    mx_node.right = now_node.right
                    if mx_node.parent.left == mx_node:
                        mx_node.parent.left = None
                    else:
                        mx_node.parent.right = None
                    if now_node.parent.left == now_node:
                        now_node.parent.left = mx_node
                    else:
                        now_node.parent.right = mx_node
                elif now_node.right:
                    mn_node = self.find_mn(now_node.right)
                    mn_node.left = now_node.left
                    mn_node.right = now_node.right
                    if mn_node.parent.left == mn_node:
                        mn_node.parent.left = None
                    else:
                        mn_node.parent.right = None
                    if now_node.parent.left == now_node:
                        now_node.parent.left = mn_node
                    else:
                        now_node.parent.right = mn_node
                else:
                    if now_node.parent.left.data == value:
                        now_node.parent.left = None
                    else:
                        now_node.parent.right = None
                return value
            elif value < now_node.data:
                now_node = now_node.left
            else:
                now_node = now_node.right

    def for_preorder(self, node, arr):
        if node is None:
            return
        arr.append(node.data)
        # print(node.data, end=' ')
        self.for_preorder(node.left, arr)
        self.for_preorder(node.right, arr)
        return arr

    def for_inorder(self, node, arr):
        if node is None:
            return
        self.for_inorder(node.left, arr)
        arr.append(node.data)
        # print(node.data, end=' ')
        self.for_inorder(node.right, arr)
        return arr

    def for_postortder(self, node, arr):
        if node is None:
            return
        self.for_postortder(node.left, arr)
        self.for_postortder(node.right, arr)
        arr.append(node.data)
        # print(node.data, end=' ')
        return arr

    def preorder(self):
        return self.for_preorder(self.root, [])

    def inorder(self):
        return self.for_inorder(self.root, [])

    def postorder(self):
        return self.for_postortder(self.root, [])


node = Node(30)
tree = BinaryTree(node)
ar = [15, 45, 8, 20, 4, 12, 17, 24, 38, 56, 33, 42, 48, 60]
# for i in range(10):
#     v = random.randint(1, 100)
#     tree.insert(v)

for a in ar:
    tree.insert(a)


# print(tree.find_mx(tree.root).data)
# print(tree.find_mn(tree.root).data)

print(tree.preorder())
print(tree.inorder())
print(tree.postorder())
```

